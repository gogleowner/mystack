
# Goroutine 궁금한 것

## Thread VS Goroutine
### 멀티 프로세싱의 필요, 쓰레드의 한계
- 몇년 전부터 무어의 법칙(반도체 집적회로의 성능이 24개월마다 2배로 증가한다는 법칙)이 깨지고, 싱글 코어의 성장의 한계가 왔다. 
- 때문에 멀티 코어를 제대로 활용하여 성능을 끌어내어야 한다.
- 대부분의 언어에서는 멀티 프로세싱을 지원하지만, 멀티 프로세싱을 구현하기는 쉽지 않다. 공유 변수, 런타임 비용 등 고려해야할 것이 많다.
- 자바의 경우 1개의 쓰레드 당 1MB의 스택 공간을 요구하고, 쓰레드와 쓰레드 사이의 보호공간이 필요하다. 많은 쓰레드를 만들수록 힙의 공간이 적어진다.
- 웹서버로 보면, 요청 한개당 쓰레드를 만든다면 OOM 에러가 발생하거나, 메모리 공간을 넘어 프로그램이 가상메모리에 페이징되면서 성능저하가 발생하게 된다.
- 즉 쓰레드는 멀티프로세싱의 해답이라 보기는 어렵다. 위의 예제는 자바 언어 뿐만 아니라 모든 언어에서 발생하는 문제이다.

### Goroutine in GO
- 한 프로세스로 모든 코어를 활용하면서 적은 메모리를 사용하는 방식이다.
  - 메모리 소비
    - 쓰레드는 한개의 당 1MB의 스택 공간을 필요로 하고, 쓰레드 사이의 보호공간이 필요하다.
    - 고루틴은 2KB의 스택 공간을 필요로 한다. 필요에 따라 힙 저장 공간을 확보하여 사용한다.
    - 고루틴으로 한 요청당 하나의 고루틴으로 처리하는 비용은 크지 않지만 쓰레드는 메모리 문제가 발생할 가능성이 크다.
  - 생성 & 종료 비용
    - 쓰레드는 OS로부터 리소스를 요청해야 하고 작업이 끝나면 리소스를 돌려줘야 하기 때문에 비용이 크다. 때문에 자바의 tomcat 등 서버는 쓰레드의 Pool을 만들어 사용한다.
    - 고루틴은 런타임에서 만들어지고 파괴되는 작업들이 매우 저렴하다.
  - Context Switching
    - 쓰레드는 작업기간 동안 블로킹 되면 다른 쓰레드가 그 자리를 스케쥴링해야 한다. 쓰레드가 바뀔 동안 스케쥴러는 모든 레지스터를 save/restore해야 한다.
      - 레지스터 목록
        - 16개의 범용 레지스터
        - PC(Program Counter)
        - SP(Stack Pointer)
        - Segment 레지스터
        - 16개의 XMM 레지스터
        - FP Coprocessor State
        - 16개의 AVX 레지스터
        - 모든 MSR들
    - 고루틴은 스케쥴링되는 동안 3개의 레지스터만이 save/restore된다.
      - 레지스터 목록
        - PC(Program Counter)
        - SP(Stack Pointer)
        - DX(Data register). 산술 연산과 I/O 명령에서 사용.
      - 블로킹된 고루틴은 고려되지 않고 동작하는 고루틴만이 고려된다.
      - 고루틴의 개수가 많더라도 현대의 스케쥴러들은 O(1) Complexity를 가지기에 개수에 영향을 받지 않는다.
- 고루틴은 블로킹이 발생하면 다른 고루틴을 스케쥴링하기 때문에 쓰레드보다 비해 리소스가 적다.
- OS의 관점에서보면 Go 프로그램은 이벤트 기반 C 프로그램과 같이 동작할 것이다.
- 데이터를 공유해야할 일이 있으면 Channel을 이용하여 고루틴간에 데이터를 전송하는 것이 가장 좋다.

### Go 언어의 동시성 모델 : CSP (Communicating Sequential Processes : 순차적 프로세스들의 통신)
- Do not communicate by sharing memory; instead, share memory by communicating. : 공유 메모리를 이용하여 커뮤니케이션 하지말고, 커뮤니케이션에 의해 메모리를 나누자.
  - 쓰레드들이 공유 될 것들을 동시간에 접근하는게 아니라, 서로 전달하는 방식이다.
- Do not communicate by sharing memory
  - 공유변수가 있을 경우 이에 대한 원자성을 보장하기 위해 동시성 객체 또는 뮤텍스 등을 사용할 것이다.
  - 결국 동시성으로 인한 race condition 문제를 생각해야하기에 이런 객체 자체를 없애라는 것으로 보인다.
- instead, share memory by communicating.
  - 데이터를 보내고 받는 주체를 나누어서 메모리를 공유하게끔 한다.
  - 쓰레드 사이에 데이터를 주고 받는 교환이 일어날 때 적합한 동기화가 발생한다. 보내는 쓰레드가 작업을 완료할 때까지 받는 쓰레드는 아무것도 하지 않는다. 순차적으로 실행되게끔 한다.
  - Go 언어에서는 Channel을 통해 고루틴끼리 통신할 수 있게 한다. (물론 대부분의 언어에서 제공하는 Locking을 위한 기능, atomic한 연산을 보장하는 기능도 있다.)

### References
- https://tech.ssut.me/goroutine-vs-threads/
- https://stonzeteam.github.io/How-Goroutines-Work/
- https://www.slideshare.net/lahuman1/java-go
- https://hamait.tistory.com/934

